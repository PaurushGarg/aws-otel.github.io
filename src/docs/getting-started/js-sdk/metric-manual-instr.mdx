---
title: 'Metrics on AWS Distro for OpenTelemetry JavaScript SDK'
description:
    Metrics auto instrumentation has not been supported in AOT/OpenTelemetry yet. We have to manually instrumenting code
    in the application to generate application metrics. Here is an example with steps for modifying application code to
    create metrics with JavaScript SDK.
path: '/docs/getting-started/js-sdk/metric-manual-instr'
---

import SectionSeparator from "components/MdxSectionSeparator/sectionSeparator.jsx"
import img2 from "assets/img/docs/img2.png"
import { Link } from "gatsby"

Metrics auto instrumentation has not been supported in AOT/OpenTelemetry yet. We have to manually instrumenting code in the application to generate application metrics. Here is an example with steps for modifying application code to create metrics with JavaScript SDK.

OpenTelemetry JavaScript SDK has provided metrics API for metrics instrumentation in applications. You can follow the steps and sample code below to create OpenTelemetry Metrics and send it over to ADOT Collector.

In this tutorial, we will introduce how to use OpenTelemetry JavaScript SDK for metric instrumentation in the application.

<SectionSeparator />

## Requirements

[Node JS v8.50 (or later)](https://nodejs.org/en/download/) is required to run an application using OpenTelemetry.

Note: Youâ€™ll also need to have the AWS Distro for OpenTelemetry Collector running to export metrics to Amazon CloudWatch.
See the ADOT Collector documentation for setup instructions.

<SectionSeparator />

## Getting the SDK and Dependencies

In order to trace your application, the following OpenTelemetry packages will be required to be installed in your applications main directory.

```bash lineNumbers=true
$ npm install \
  @opentelemetry/api \
  @opentelemetry/sdk-node \
  @opentelemetry/exporter-metrics-otlp-grpc \
  @opentelemetry/sdk-metrics \
  @opentelemetry/api-metrics
```

## Instrumenting Code
Once OpenTelemetry Dependencies have been imported to application, we can start to instrument code for creating metrics.

1. Initiate OpenTelemetry with components to export metrics to ADOT Collector
```javascript lineNumbers=true
const process = require('process');
const opentelemetry = require("@opentelemetry/sdk-node");
const { Resource } = require("@opentelemetry/resources");
const { SemanticResourceAttributes } = require("@opentelemetry/semantic-conventions");
const { PeriodicExportingMetricReader } = require("@opentelemetry/sdk-metrics");
const { OTLPMetricExporter } = require("@opentelemetry/exporter-metrics-otlp-grpc");

const _resource = Resource.default().merge(new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: "js-sample-app",
    }));
}
const _metricReader = new PeriodicExportingMetricReader({
    exporter: new OTLPMetricExporter(),
    exportIntervalMillis: 1000
});

async function nodeSDKBuilder() {
    const sdk = new opentelemetry.NodeSDK({
        metricReader: _metricReader,
        resource: _resource,
    });
    
    // this enables the API to record telemetry
    await sdk.start(); 
    // gracefully shut down the SDK on process exit
    process.on('SIGTERM', () => {
    sdk.shutdown()
      .then(() => console.log('Metrics terminated'))
      .catch((error) => console.log('Error terminating metrics', error))
      .finally(() => process.exit(0));
    });
}
```

3. Define Metrics and metrics labels(dimensions) for the application
In the following example application we demonstrate how to use the three types of metric instruments that
are available to record metrics: Counters, Gauges and Histograms.

[Counters](https://opentelemetry.io/docs/reference/specification/metrics/api/#counter):
```JavaScript
const metricsApi = require('@opentelemetry/api-metrics');
const common_attributes = { signal: 'metric',  language: 'javascript', metricType: 'random' };
const TIME_ALIVE_METRIC = 'timeAlive';
const HEAP_SIZE_METRIC = 'totalHeapSize';

// acquire meter 
const meter = metricsApi.metrics.getMeter('js-sample-app-meter');

// synchronous counter metric
const timeAliveMetric = meter.createCounter(TIME_ALIVE_METRIC, {
    description: 'Total amount of time that the application has been alive',
    unit: 's'
});

// asynchronous updown counter metric
const totalHeapSizeMetric = meter.createObservableUpDownCounter(HEAP_SIZE_METRIC, {
    description: 'The current total heap size',
    unit:'1'
});
totalHeapSizeMetric.addCallback((measurement) => {measurement.observe(totalHeapSize, common_attributes)});

// updates updown counter
function updateSizeMetric() {
    totalHeapSize += Math.random() * cfg.RandomTotalHeapSizeUpperBound;
}
```

[Gauges](https://opentelemetry.io/docs/reference/specification/metrics/api/#asynchronous-gauge):
```JavaScript
const metricsApi = require('@opentelemetry/api-metrics');
const common_attributes = { signal: 'metric',  language: 'javascript', metricType: 'random' };
const CPU_USAGE_METRIC = 'cpuUsage';
let cpuUsage = 0;

// acquire meter 
const meter = metricsApi.metrics.getMeter('js-sample-app-meter');

// observable gauge metric
const cpuUsageMetric = meter.createObservableGauge(CPU_USAGE_METRIC, {
    description: 'Cpu usage percent',
    unit: '1'
});
cpuUsageMetric.addCallback((measurement) => {measurement.observe(cpuUsage, common_attributes)});

// updates observable gauge
function updateCpuUsageMetric() {
    cpuUsage = Math.random() * cfg.RandomCpuUsageUpperBound;
}
```

[Histograms](https://opentelemetry.io/docs/reference/specification/metrics/api/#histogram):
```JavaScript
const metricsApi = require('@opentelemetry/api-metrics');
const commmon_attributes = { signal: 'metric',  language: 'javascript', metricType: 'request' };
const LATENCY_TIME = 'latencyTime';

// acquire meter 
const meter = metricsApi.metrics.getMeter('js-sample-app-meter');

const latencyTimeMetric = meter.createHistogram(LATENCY_TIME, {
    description: "Measures latency time.",
    unit: 'ms'
});
```

4. Send metrics
```javascript lineNumbers=true
  setInterval(() => {
    timeAliveMetric.add(cfg.RandomTimeAliveIncrementer, common_attributes);
    updateSizeMetric();
    updateCpuUsageMetric();
    latencyTimeMetric.record(returnTime, attributes);
  }, cfg.TimeInterval * 1000);
```

These steps provided the sample code for applications to create application metrics.

Please follow <Link to="/docs/getting-started/cloudwatch-metrics">Getting Started Sending CloudWatch Metrics with AWS OpenTelemetry</Link>
 to setup ADOT Collector for sending metrics to CloudWatch. Once ADOT Collector is installed to collect the metrics data.
 You should see the following metrics present on your CloudWatch Console.

<img src={img2} alt="Diagram" style="margin: 30px 0;" />

Please stay tuned to [AWS Observability Repo](https://github.com/aws-observability) for more updates.